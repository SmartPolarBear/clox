// Copyright (c) 2021 SmartPolarBear
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#pragma once

// Copyright (c) 2021 SmartPolarBear
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


// WARNING: generated by parser_gen.py, DO NOT MODIFY MANUALLY
#pragma once
#include <scanner/scanner.h>
#include <parser/expression.h>
#include <any>
#include <memory>
#include <stdexcept>
#include "parser_base.inc"
namespace clox::parsing {
template<typename T> class visitor{
public:
virtual T visit_binary_expression(class binary_expression*)=0;
virtual T visit_unary_expression(class unary_expression*)=0;
virtual T visit_literal(class literal*)=0;
virtual T visit_grouping(class grouping*)=0;
};
class binary_expression:public expression{
public:
binary_expression(const binary_expression&)=default;
binary_expression(binary_expression&&)=default;
binary_expression& operator=(const binary_expression&)=default;
[[nodiscard]] explicit binary_expression(std::shared_ptr<expression> left,clox::scanning::token op,std::shared_ptr<expression> right):left_(left),op_(op),right_(right){}
[[nodiscard]] auto& get_left(){
return this->left_;}
[[nodiscard]] auto& get_op(){
return this->op_;}
[[nodiscard]] auto& get_right(){
return this->right_;}
void set_left(const std::shared_ptr<expression>&left){
left_=left;}
void set_op(const clox::scanning::token&op){
op_=op;}
void set_right(const std::shared_ptr<expression>&right){
right_=right;}
[[nodiscard]] parser_class_type get_type()const override{return PC_TYPE_binary_expression;}
template<typename T>[[nodiscard]] T accept(visitor<T> &vis){
return vis.visit_binary_expression(this);
}
private:
std::shared_ptr<expression> left_;
clox::scanning::token op_;
std::shared_ptr<expression> right_;
};
class unary_expression:public expression{
public:
unary_expression(const unary_expression&)=default;
unary_expression(unary_expression&&)=default;
unary_expression& operator=(const unary_expression&)=default;
[[nodiscard]] explicit unary_expression(clox::scanning::token op,std::shared_ptr<expression> right):op_(op),right_(right){}
[[nodiscard]] auto& get_op(){
return this->op_;}
[[nodiscard]] auto& get_right(){
return this->right_;}
void set_op(const clox::scanning::token&op){
op_=op;}
void set_right(const std::shared_ptr<expression>&right){
right_=right;}
[[nodiscard]] parser_class_type get_type()const override{return PC_TYPE_unary_expression;}
template<typename T>[[nodiscard]] T accept(visitor<T> &vis){
return vis.visit_unary_expression(this);
}
private:
clox::scanning::token op_;
std::shared_ptr<expression> right_;
};
class literal:public expression{
public:
literal(const literal&)=default;
literal(literal&&)=default;
literal& operator=(const literal&)=default;
[[nodiscard]] explicit literal(std::any value):value_(value){}
[[nodiscard]] auto& get_value(){
return this->value_;}
void set_value(const std::any&value){
value_=value;}
[[nodiscard]] parser_class_type get_type()const override{return PC_TYPE_literal;}
template<typename T>[[nodiscard]] T accept(visitor<T> &vis){
return vis.visit_literal(this);
}
private:
std::any value_;
};
class grouping:public expression{
public:
grouping(const grouping&)=default;
grouping(grouping&&)=default;
grouping& operator=(const grouping&)=default;
[[nodiscard]] explicit grouping(std::shared_ptr<expression> expr):expr_(expr){}
[[nodiscard]] auto& get_expr(){
return this->expr_;}
void set_expr(const std::shared_ptr<expression>&expr){
expr_=expr;}
[[nodiscard]] parser_class_type get_type()const override{return PC_TYPE_grouping;}
template<typename T>[[nodiscard]] T accept(visitor<T> &vis){
return vis.visit_grouping(this);
}
private:
std::shared_ptr<expression> expr_;
};
template<typename T>static inline T accept(const expression& expr,visitor<T> &vis){
switch(expr.get_type()){
case PC_TYPE_binary_expression:
return (( binary_expression &)(expr)).accept<T>(vis);
break;
case PC_TYPE_unary_expression:
return (( unary_expression &)(expr)).accept<T>(vis);
break;
case PC_TYPE_literal:
return (( literal &)(expr)).accept<T>(vis);
break;
case PC_TYPE_grouping:
return (( grouping &)(expr)).accept<T>(vis);
break;
default:
throw std::invalid_argument("expr");
}
}
}
// generated by parser_gen.py, DO NOT MODIFY MANUALLY
